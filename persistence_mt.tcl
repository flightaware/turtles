#!/usr/bin/env tclsh
package require Tcl     8.5 8.6
package require Thread
package require sqlite3

package require turtles::persistence::base 0.1

## \file persistence_mt.tcl
#
# A separate worker thread (recorder) courtesy of the Tcl Thread library
# marshals persistence requests. Another worker thread (scheduler)
# maintains a periodic notification sent to the recorder to induce
# a stage transfer from ephemeral to finalized for any new trace
# information since the last transfer. All data once transferred
# is wiped from the ephemeral stage to keep memory costs down.
#
# To persist trace information, it is recommended to invoke
# \c ::turtles::persistence::mt::start with the appropriate parameters
# and _then_ add trace hooks.
# To stop persistence, it is recommended to remove the relevant
# trace hooks and _then_ invoke \c ::turtles::persistence::mt::stop.
#
# Under the hood, these procs use thread::send to induce the
# recorder thread to perform the requisite SQL calls.

## Namespace for handling persistence of trace information generated by the turtles package.
#
# The scheduling of staged persistence is accomplished by interthread communication.
namespace eval ::turtles::persistence::mt {
	variable recorder
	variable scheduler
	variable stages
	namespace export start stop add_proc_id add_call update_call recorder scheduler stages
}

## Adds a proc id to the proc id table in the stage 0 persistence DB.
#
# NB: If there is a conflict, i.e., if the given procId and/or procName
# already exist in the stage 0 persistence DB proc_ids table, the existing
# record will NOT be overwritten, and the proc will swallow the conflict.
#
# \param[in] procId proc name hash
# \param[in] procName proc name
# \param[in] timeDefined the epoch time in microseconds at which the proc definition was invoked
# \param[in] awaiter an optional variable name reference that the caller can await on
proc ::turtles::persistence::mt::add_proc_id {procId procName timeDefined {awaiter {}}} {
	set lambda [::turtles::persistence::base::add_proc_id [namespace current]::stages $procId $procName $timeDefined]
	thread::send -async $::turtles::persistence::mt::recorder $lambda $awaiter
}

## Adds a call point to the call point table in the stage 0 persistence DB to record proc entry.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeEnter the epoch time in microseconds at which the proc began
# \param[in] timeLeave the epoch time in microseconds at which the proc finished (optional)
# \param[in] awaiter an optional variable name reference that the caller can await on
proc ::turtles::persistence::mt::add_call {callerId calleeId traceId timeEnter {timeLeave {NULL}} {awaiter {}}} {
	set lambda [::turtles::persistence::base::add_call [namespace current]::stages $callerId $calleeId $traceId $timeEnter $timeLeave]
	thread::send -async $::turtles::persistence::mt::recorder $lambda $awaiter
}

## Updates a previously added call point in the call point table in the stage 0 persistence DB to record proc exit.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeLeave the epoch time in microseconds at which the proc exit handler was triggered
# \param[in] awaiter an optional variable name reference that the caller can await on
proc ::turtles::persistence::mt::update_call {callerId calleeId traceId timeLeave {awaiter {}}} {
	set lambda [::turtles::persistence::base::update_call [namespace current]::stages $callerId $calleeId $traceId $timeLeave]
	thread::send -async $::turtles::persistence::mt::recorder $lambda $awaiter
}

## Initializes the turtles persistence model.
#
# Note that in \c direct mode the persistence model writes directly to the final DB.
#
# \param[in] commitMode the mode for persistence (\c staged | \c direct) [default: \c staged]
# \param[in] intervalMillis the number of milliseconds between stage transfers [default: 30000]
# \param[in] dbPath the path where the finalized persistence is stored as a sqlite DB [default: ./]
# \param[in] dbPrefix the filename prefix of the finalized persistence is stored as a sqlite DB. The PID and .db extension are appended [default: turtles]
proc ::turtles::persistence::mt::start {{commitMode staged} {intervalMillis 30000} {dbPath ./} {dbPrefix {turtles}}} {
	set fqdb [turtles::persistence::base::get_db_filename $dbPath $dbPrefix]
	switch $commitMode {
		staged {
			set ::turtles::persistence::mt::recorder [thread::create -joinable [subst {
				package require Tcl 8.5 8.6
				package require Thread
				package require sqlite3
				package require turtles::persistence::mt

				::turtles::persistence::base::init_stages [namespace current]::stages $commitMode $fqdb
				thread::wait
			}]]
			set ::turtles::persistence::mt::scheduler [thread::create [subst {
				package require Tcl 8.5 8.6
				package require Thread
				package require turtles::persistence::mt
				::turtles::persistence::mt::schedule_finalize $::turtles::persistence::mt::recorder [namespace current]::stages $intervalMillis
				vwait ::turtles::persistence::mt::scheduler_off
			}]]
		}
		direct {
			set ::turtles::persistence::mt::recorder [thread::create -joinable [subst {
				package require Tcl 8.5 8.6
				package require Thread
				package require sqlite3
				package require turtles::persistence::mt
				::turtles::persistence::base::init_stages [namespace current]::stages $commitMode $fqdb
				thread::wait
			}]]
		}
		default {
			error "::turtles::persistence::start: invalid commit mode '$commitMode'. Valid options are 'staged' or 'direct'."
		}
	}
}


## Halts and tears down the turtles persistence model.
#
# If the model is operating in \c staged mode, any pending
# \c ::turtles::persistence::base::finalize call is cancelled, and an
# explicit call is made immediately to transfer the remaining
# unfinalized information from the ephemeral to the finalized DB.
#
# The underlying sqlite DB(s) introduced via \c ::turtles::persistence::mt::start
# are closed and any pertinent namespace variables are unset.
#
# NB: This proc should not be called until all the relevant trace hooks are eliminated.
proc ::turtles::persistence::mt::stop {} {
	# Stop scheduler worker thread.
	if { [info exists ::turtles::persistence::mt::scheduler] && [thread::exists $::turtles::persistence::mt::scheduler] } {
		thread::send $::turtles::persistence::mt::scheduler {
			foreach jid [after info] { after cancel $jid }
			set ::turtles::persistence::mt::scheduler_off 1
		}
	}

	# Stop recorder worker thread.
	if { [info exists ::turtles::persistence::mt::recorder] && [thread::exists $::turtles::persistence::mt::recorder] } {
		set lambda { ::turtles::persistence::base::stop_recorder [namespace current]::stages }
		thread::send $::turtles::persistence::mt::recorder $lambda
		thread::release $::turtles::persistence::mt::recorder
		thread::join $::turtles::persistence::mt::recorder
	}
}


## The self-perpetuating worker that continually transfers ephemeral trace information to the finalized DB.
#
# This function is only invoked if the persistence model is invoked in \c staged mode.
#
# NB: This function should only be executed directly in the scheduler thread.
#
# \param[in] recorderThread the thread handling the database interaction
# \param[in] the sqlite3 db command name
# \param[in] intervalMillis the number of milliseconds between operations
proc ::turtles::persistence::mt::schedule_finalize {recorderThread stages intervalMillis} {
	if { [thread::exists $recorderThread] } {
		# Finalize the next batch of uncommitted records.
		thread::send -async $recorderThread [subst { ::turtles::persistence::base::finalize $stages }]
		#Set an alarm to wake up and do it again.
		after $intervalMillis [list ::turtles::persistence::mt::schedule_finalize $recorderThread $stages $intervalMillis]
	} else {
		error "No active recorder thread!"
	}
}

package provide turtles::persistence::mt 0.1
