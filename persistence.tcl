#!/usr/bin/env tclsh
package require Tcl     8.5
package require Thread
package require sqlite3

## \file persistence.tcl
# Provides the mechanisms for the proc entry and exit handlers to persist
# trace information about proc execution for the purpose of building call
# graphs and other execution analysis artifacts.
#
# Under the hood, the library makes extensive use of Tcl's
# sqlite facilities for portability and ease of aggregation.
#
# Persistence is handled in two stages: ephemeral and final.
# During the ephemeral stage, the handlers access an in-memory
# sqlite database (created with the \c :memory: literal name).
#
# A separate worker thread courtesy of the Tcl Thread library
# marshals persistence requests and maintains a periodic stage
# transfer in the worker thread's event loop which copies rows
# from the ephemeral stage whose timestamps exceed the last known
# finalized timestamp. To minimize the use of global variables,
# is passed as an argument to the periodic transfer function.
#
# If the program crashes or otherwise suddenly exits, any
# information which has not transitioned from the ephemeral to
# the final stage will be lost. An option is provided to allow
# consumers to skip the ephemeral stage and write directly to
# final storage at the cost of increased overhead and decreased
# performance.
#
# The writes to ephemeral storage are marshalled through the
# ::turtles::persistence::send* family of functions. These
# use thread::send to induce the worker thread to perform
# the requisite SQL calls.

## Namespace for handling persistence of trace information generated by the turtles package.
namespace eval ::turtles::persistence {
	namespace export start stop add_proc_id add_call update_call
}

set ::turtles::persistence::script [file normalize [info script]]

## Creates the proc id table if it does not already exist.
#
# \param[in] stage persistence stage DB
proc ::turtles::persistence::init_proc_id_table {stage} {
	$stage eval {
		CREATE TABLE IF NOT EXISTS proc_ids
		(proc_id INT UNIQUE, proc_name TEXT UNIQUE, time_defined INT);
	}
}

## Creates the call point table if it does not already exist
#
# \param[in] stage persistence stage DB
proc ::turtles::persistence::init_call_pt_table {stage} {
	$stage eval {
		CREATE TABLE IF NOT EXISTS call_pts
		(caller_id INT, callee_id INT, trace_id INT, time_enter INT, time_leave INT);
		CREATE INDEX IF NOT EXISTS call_pt_edge_idx ON call_pts(caller_id, callee_id);
	}
}

## Adds a proc id to the proc id table in the stage 0 persistence DB.
#
# \param[in] procId proc name hash
# \param[in] procName proc name
# \param[in] timeDefined the epoch time in microseconds at which the proc definition was invoked
proc ::turtles::persistence::add_proc_id {procId procName timeDefined} {
	thread::send -async $::turtles::persistence::sqliteWorker [subst {
		::turtles::persistence::stage0 eval {
			INSERT INTO proc_ids (proc_id, proc_name, time_defined)
			VALUES($procId, $procName, $timeDefined);
		}
	}]
}

## Adds a call point to the call point table in the stage 0 persistence DB to record proc entry.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeEnter the epoch time in microseconds at which the proc entry handler was triggered
proc ::turtles::persistence::add_call {callerId calleeId traceId timeEnter} {
	thread::send -async $::turtles::persistence::sqliteWorker [subst {
		::turtles::persistence::stage0 eval {
			INSERT INTO call_pts (caller_id, callee_id, trace_id, time_enter, time_leave)
			VALUES($callerId, $calleeId, $traceId, $timeEnter);
		}
	}]
}

## Updates a previously added call point in the call point table in the stage 0 persistence DB to record proc exit.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeLeave the epoch time in microseconds at which the proc exit handler was triggered
proc ::turtles::persistence::update_call {callerId calleeId traceId timeLeave} {
	thread::send -async $::turtles::persistence::sqliteWorker [subst {
		::turtles::persistence::stage0 eval {
			UPDATE call_pts SET time_leave = $traceId
			WHERE caller_id = $callerId AND callee_id = $calleeId AND trace_id = $trace_id;
		}
	}]														   
}

## The self-perpetuating worker that continually transfers ephemeral trace information to the finalized DB.
#
# This function is only invoked if the persistence model is invoked in \c staged mode.
#
# \param[in] intervalMillis the number of milliseconds between operations
proc ::turtles::persistence::finalize_worker {lastFinalizeTime intervalMillis} {
	# Finalize the next batch of uncommitted records.
	set finalizeTime [::turtles::persistence::finalize $lastFinalizeTime]
	# Set an alarm to wake up and do it again.
	set ::turtles::persistence::nextFinalize [after $intervalMillis [list ::turtles::persistence::finalize_worker $finalizeTime $intervalMillis]]
}

## Transfers trace information from the ephemeral to the finalized DB.
proc ::turtles::persistence::finalize {lastFinalizeTime} {
	set finalizeTime [clock microseconds]
	# Only proceed if the databases exist.
	if { [info comm ::turtles::persistence::stage0 ] ne {} &&
		 [info comm ::turtles::persistence::stage1 ] ne {} } {
		# Copy proc ids from the last finalized to the present into the final DB.
		::turtles::persistence::stage0 eval {
			SELECT proc_id, proc_name, time_defined FROM proc_ids
			WHERE time_defined > $lastFinalizeTime
			  AND time_defined <= $finalizeTime;
		} values {
			::turtles::persistence::stage1 eval {
				INSERT INTO proc_ids (proc_id, proc_name, time_defined)
				VALUES ([lindex values 0], [lindex values 1], [lindex values 2]);
			}
		}
		# Copy _finalized_ call points from the last finalized to the present into the final DB.
		::turtles::persistence::stage0 eval {
			SELECT caller_id, callee_id, trace_id, time_enter, time_leave FROM call_pts
			WHERE time_leave IS NOT NULL
			  AND time_leave > $lastFinalizeTime
			  AND time_leave <= $finalizeTime;
		} values {
			::turtles::persistence::stage1 eval {
				INSERT INTO call_pts (caller_id, callee_id, trace_id, time_enter, time_leave)
				VALUES ([lindex values 0], [lindex values 1], [lindex values 2], [lindex values 3], [lindex values 4]);
			}
		}
	}
	# Update caller with new last finalize time.
	return $finalizeTime
}

## Initializes the turtles persistence model.
#
# Note that in \c direct mode the persistence model writes directly to the final DB.
# 
# \param[in] finalDB the file for finalized persistence as a sqlite DB
# \param[in] commitMode the mode for persistence (\c staged | \c direct) [default: \c staged]
# \param[in] intervalMillis the number of milliseconds between stage transfers
proc ::turtles::persistence::start {finalDB {commitMode staged} {intervalMillis 1000}} {
	switch $commitMode {
		staged {
			set ::turtles::persistence::sqliteWorker [thread::create -joinable [subst {
				package require Tcl 8.5
				package require Thread
				package require sqlite3
				source $::turtles::persistence::script
				sqlite3 ::turtles::persistence::stage0 :memory:
				sqlite3 ::turtles::persistence::stage1 $finalDB
				::turtles::persistence::init_proc_id_table ::turtles::persistence::stage0
				::turtles::persistence::init_call_pt_table ::turtles::persistence::stage0
				::turtles::persistence::init_proc_id_table ::turtles::persistence::stage1
				::turtles::persistence::init_call_pt_table ::turtles::persistence::stage1
				set ::turtles::persistence::nextFinalize [after $intervalMillis [list ::turtles::persistence::finalize_worker 0 $intervalMillis]]
				thread::wait
			}]]
		}
		direct {
			set ::turtles::persistence::sqliteWorker [thread::create -joinable [subst {
				package require Tcl 8.5
				package require Thread
				package require sqlite3
				source $::turtles::persistence::script
				sqlite3 ::turtles::persistence::stage0 $finalDB
				::turtles::persistence::init_proc_id_table ::turtles::persistence::stage0
				::turtles::persistence::init_call_pt_table ::turtles::persistence::stage0
				thread::wait
			}]]
		}
		default {
			error "::turtles::persistence::start: invalid commit mode '$commitMode'. Valid options are 'staged' or 'direct'."
		}
	}
}

## Halts and tears down the turtles persistence model.
#
# If the model is operating in \c staged mode, any pending
# ::turtles::persistence::finalize call is cancelled, and an
# explicit call is made immediately to transfer the remaining
# unfinalized information from the ephemeral to the finalized DB.
#
# The underlying sqlite DB(s) introduced via \c ::turtles::persistence::start
# are closed and any pertinent namespace variables are unset.
proc ::turtles::persistence::stop {} {
	if { [info exists ::turtles::persistence::sqliteWorker] && [thread::exists $::turtles::persistence::sqliteWorker] } {
		thread::send $::turtles::persistence::sqliteWorker {
			if { [info comm ::turtles::persistence::stage1 ] ne {} } {
				# Force any pending finalize call.
				update
				# Cancel the newly pending finalize call.
				after cancel ::turtles::persistence::nextFinalize
				# Remove the pending finalize call handle.
				unset ::turtles::persistence::nextFinalize
				# Close the finalized database.
				::turtles::persistence::stage1 close
			}
			if { [info comm ::turtles::persistence::stage0 ] ne {} } {
				# Close the ephemeral database.
				::turtles::persistence::stage0 close
			}
		}
		thread::release $::turtles::persistence::sqliteWorker
		thread::join $::turtles::persistence::sqliteWorker
	}
}

package provide turtles::persistence 0.1
