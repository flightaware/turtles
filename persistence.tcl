#!/usr/bin/env tclsh
package require Tcl     8.5
package require Thread
package require sqlite3

## \file persistence.tcl
# Provides the mechanisms for the proc entry and exit handlers to persist
# trace information about proc execution for the purpose of building call
# graphs and other execution analysis artifacts.
#
# Under the hood, the library makes extensive use of Tcl's
# sqlite facilities for portability and ease of aggregation.
#
# Persistence is handled in two stages: ephemeral and final.
# During the ephemeral stage, the handlers access an in-memory
# sqlite database (created with the \c :memory: literal name).
#
# A separate worker thread courtesy of the Tcl Thread library
# marshals persistence requests and maintains a periodic stage
# transfer in the worker thread's event loop which copies rows
# from the ephemeral stage whose timestamps exceed the last known
# finalized timestamp. To minimize the use of global variables,
# is passed as an argument to the periodic transfer function.
#
# If the program crashes or otherwise suddenly exits, any
# information which has not transitioned from the ephemeral to
# the final stage will be lost. An option is provided to allow
# consumers to skip the ephemeral stage and write directly to
# final storage at the cost of increased overhead and decreased
# performance.
#
# The writes to ephemeral storage are marshalled through the
# ::turtles::persistence::send* family of functions. These
# use thread::send to induce the worker thread to perform
# the requisite SQL calls.

## Namespace for handling persistence of trace information generated by the turtles package.
namespace eval ::turtles::persistence {
	namespace export start stop add_proc_id add_call update_call
}

set ::turtles::persistence::script [file normalize [info script]]

## Creates the proc id table if it does not already exist.
#
# \param[in] stage persistence stage DB
proc ::turtles::persistence::init_proc_id_table {stage} {
	$stage eval {
		CREATE TABLE IF NOT EXISTS proc_ids
		(proc_id INT UNIQUE, proc_name TEXT UNIQUE, time_defined INT);
	}
}

## Creates the call point table if it does not already exist
#
# \param[in] stage persistence stage DB
proc ::turtles::persistence::init_call_pt_table {stage} {
	$stage eval {
		CREATE TABLE IF NOT EXISTS call_pts
		(caller_id INT, callee_id INT, trace_id INT, time_enter INT, time_leave INT);
		CREATE INDEX IF NOT EXISTS call_pt_edge_idx ON call_pts(caller_id, callee_id);
	}
}

## Adds a proc id to the proc id table in the stage 0 persistence DB.
#
# \param[in] procId proc name hash
# \param[in] procName proc name
# \param[in] timeDefined the epoch time in microseconds at which the proc definition was invoked
proc ::turtles::persistence::add_proc_id {procId procName timeDefined} {
	thread::send -async $::turtles::persistence::finalizer [subst {
		puts "add_proc_id: $procId $procName $timeDefined"
		::turtles::persistence::stage0 eval {
			INSERT INTO proc_ids (proc_id, proc_name, time_defined)
			VALUES($procId, '$procName', $timeDefined);
		}
	}]
}

## Adds a call point to the call point table in the stage 0 persistence DB to record proc entry.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeEnter the epoch time in microseconds at which the proc entry handler was triggered
proc ::turtles::persistence::add_call {callerId calleeId traceId timeEnter} {
	thread::send -async $::turtles::persistence::finalizer [subst {
		puts "add_call: $callerId $calleeId $traceId $timeEnter"
		::turtles::persistence::stage0 eval {
			INSERT INTO call_pts (caller_id, callee_id, trace_id, time_enter)
			VALUES($callerId, $calleeId, $traceId, $timeEnter);
		}
	}]
}

## Updates a previously added call point in the call point table in the stage 0 persistence DB to record proc exit.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeLeave the epoch time in microseconds at which the proc exit handler was triggered
proc ::turtles::persistence::update_call {callerId calleeId traceId timeLeave} {
	thread::send -async $::turtles::persistence::finalizer [subst {
		puts "update_call: $callerId $calleeId $traceId $timeLeave"
		::turtles::persistence::stage0 eval {
			UPDATE call_pts SET time_leave = $timeLeave
			WHERE caller_id = $callerId AND callee_id = $calleeId AND trace_id = $traceId;
		}
	}]
}

## The self-perpetuating worker that continually transfers ephemeral trace information to the finalized DB.
#
# This function is only invoked if the persistence model is invoked in \c staged mode.
#
# \param[in] intervalMillis the number of milliseconds between operations
proc ::turtles::persistence::schedule_finalize {stage0 stage1 lastFinalizeTime intervalMillis} {
	# Finalize the next batch of uncommitted records.
	set finalizeTime [::turtles::persistence::finalize $stage0 $stage1 $lastFinalizeTime]
	# Set an alarm to wake up and do it again.
	set ::turtles::persistence::nextFinalize [after $intervalMillis ::turtles::persistence::schedule_finalize $stage0 $stage1 $finalizeTime $intervalMillis]
}

## Transfers trace information from the ephemeral to the finalized DB.
proc ::turtles::persistence::finalize {stage0 stage1 lastFinalizeTime} {
	set finalizeTime [clock microseconds]
	# Only proceed if the databases exist.
	if { [info comm $stage0 ] ne {} && [info comm $stage1 ] ne {} } {
		puts "finalize $stage0 $stage1 $lastFinalizeTime \[$finalizeTime\]"
		# Copy proc ids from the last finalized to the present into the final DB.
		$stage0 eval {
			SELECT proc_id, proc_name, time_defined FROM proc_ids
			WHERE time_defined > $lastFinalizeTime
			  AND time_defined <= $finalizeTime;
		} values {
			parray values
			$stage1 eval {
				INSERT INTO proc_ids (proc_id, proc_name, time_defined)
				VALUES ($values(proc_id), $values(proc_name), $values(time_defined));
			}
		}
		# Copy _finalized_ call points from the last finalized to the present into the final DB.
		$stage0 eval {
			SELECT caller_id, callee_id, trace_id, time_enter, time_leave FROM call_pts
			WHERE time_leave IS NOT NULL
			  AND time_leave > $lastFinalizeTime
			  AND time_leave <= $finalizeTime;
		} values {
			parray values
			$stage1 eval {
				INSERT INTO call_pts (caller_id, callee_id, trace_id, time_enter, time_leave)
				VALUES ($values(caller_id), $values(callee_id), $values(trace_id), $values(time_enter), $values(time_leave));
			}
		}
	}
	# Update caller with new last finalize time.
	return $finalizeTime
}

## Initializes the turtles persistence model.
#
# Note that in \c direct mode the persistence model writes directly to the final DB.
#
# \param[in] finalDB the file for finalized persistence as a sqlite DB
# \param[in] commitMode the mode for persistence (\c staged | \c direct) [default: \c staged]
# \param[in] intervalMillis the number of milliseconds between stage transfers
proc ::turtles::persistence::start {finalDB {commitMode staged} {intervalMillis 1000}} {
	switch $commitMode {
		staged {
			set ::turtles::persistence::finalizer [thread::create -joinable [subst {
				package require Tcl 8.5
				package require Thread
				package require sqlite3
				source $::turtles::persistence::script
				::turtles::persistence::init_stage ::turtles::persistence::stage0
				::turtles::persistence::init_stage ::turtles::persistence::stage1 $finalDB
				::turtles::persistence::start_finalizer ::turtles::persistence::stage0 ::turtles::persistence::stage1 $intervalMillis
				thread::wait
			}]]
			#thread::configure $::turtles::persistence::finalizer -unwindonerror 1
		}
		direct {
			set ::turtles::persistence::finalizer [thread::create -joinable [subst {
				package require Tcl 8.5
				package require Thread
				package require sqlite3
				source $::turtles::persistence::script
				::turtles::persistence::init_stage ::turtles::persistence::stage0 $finalDB
				thread::wait
			}]]
			#thread::configure $::turtles::persistence::finalizer -unwindonerror 1
		}
		default {
			error "::turtles::persistence::start: invalid commit mode '$commitMode'. Valid options are 'staged' or 'direct'."
		}
	}
}

proc ::turtles::persistence::init_stage {stage {stageName :memory:}} {
	sqlite3 $stage $stageName
	::turtles::persistence::init_proc_id_table $stage
	::turtles::persistence::init_call_pt_table $stage
}

proc ::turtles::persistence::close_stage {stage} {
	if { [info comm $stage] ne {} } {
		$stage close
	}
}

proc ::turtles::persistence::start_finalizer {stage0 stage1 intervalMillis} {
	set ::turtles::persistence::nextFinalize [after $intervalMillis ::turtles::persistence::schedule_finalize $stage0 $stage1 0 $intervalMillis ]
}

proc ::turtles::persistence::stop_finalizer {stage0 {stage1 {}}} {
	if { $stage1 ne {} && [info comm $stage1 ] ne {} } {
		# Force any pending finalize call to execute.
		update
		# Cancel the newly pending finalize call.
		after cancel ::turtles::persistence::nextFinalize
		# @FIXME: Ugly hack to flush pending trace info until after semantics can be sorted out.
		::turtles::persistence::finalize $stage0 $stage1 0
		# Remove the pending finalize call handle.
		unset ::turtles::persistence::nextFinalize
	}
}

## Halts and tears down the turtles persistence model.
#
# If the model is operating in \c staged mode, any pending
# ::turtles::persistence::finalize call is cancelled, and an
# explicit call is made immediately to transfer the remaining
# unfinalized information from the ephemeral to the finalized DB.
#
# The underlying sqlite DB(s) introduced via \c ::turtles::persistence::start
# are closed and any pertinent namespace variables are unset.
proc ::turtles::persistence::stop {} {
	if { [info exists ::turtles::persistence::finalizer] && [thread::exists $::turtles::persistence::finalizer] } {
		thread::send $turtles::persistence::finalizer {
			::turtles::persistence::stop_finalizer ::turtles::persistence::stage0 ::turtles::persistence::stage1
			::turtles::persistence::close_stage ::turtles::persistence::stage1
			::turtles::persistence::close_stage ::turtles::persistence::stage0
		}
		thread::release $::turtles::persistence::finalizer
		thread::join $::turtles::persistence::finalizer
	}
}

package provide turtles::persistence 0.1
