#!/usr/bin/env tclsh
package require Tcl     8.5 8.6
package require Thread
package require sqlite3

# #!/usr/bin/env tclsh

package require turtles::persistence::lambda 0.1

## \file persistence.tcl
# Provides the mechanisms for the proc entry and exit handlers to persist
# trace information about proc execution for the purpose of building call
# graphs and other execution analysis artifacts.
#
# Under the hood, the library makes extensive use of Tcl's
# sqlite facilities for portability and ease of aggregation.
#
# Persistence is handled in two stages: ephemeral (0) and final (1).
# During the ephemeral stage, the handlers access an in-memory
# sqlite database (created with the \c :memory: literal name).
#
# A separate worker thread (recorder) courtesy of the Tcl Thread library
# marshals persistence requests. Another worker thread (scheduler)
# maintains a periodic notification sent to the recorder to induce
# a stage transfer from ephemeral to finalized for any new trace
# information since the last transfer. Novelty is defined by the
# timestamps of the trace information records and is calculated
# within the recorder's finalize function from the stage 1 tables
# so as to prevent unnecessary and complicated accounting of timestamps.
#
# If the program crashes or otherwise suddenly exits, any
# information which has not transitioned from the ephemeral to
# the final stage will be lost. An option is provided to allow
# consumers to skip the ephemeral stage and write directly to
# final storage at the cost of increased overhead and decreased
# performance.
#
# To persist trace information, it is recommended to invoke
# \c ::turtles::persistence::start with the appropriate parameters
# and _then_ add trace hooks.
# To stop persistence, it is recommended to remove the relevant
# trace hooks and _then_ invoke \c ::turtles::persistence::stop.
#
# The writes to ephemeral storage are marshalled implicitly
# through the following functions:
#
# * \c ::turtles::persistence::add_proc_id
# * \c ::turtles::persistence::add_call
# * \c ::turtles::persistence::update_call
#
# Under the hood, these procs use thread::send to induce the
# recorder thread to perform the requisite SQL calls.

## Namespace for handling persistence of trace information generated by the turtles package.
namespace eval ::turtles::persistence {
	namespace export start stop add_proc_id add_call update_call
}

## Necessary global variable so that threads can access the functions
# defined in this file.
set ::turtles::persistence::script [file normalize [info script]]

## Creates the proc id table if it does not already exist.
#
# \param[in] stage persistence stage DB
proc ::turtles::persistence::init_proc_id_table {stage} {
	$stage eval {
		CREATE TABLE IF NOT EXISTS proc_ids
		(proc_id INT UNIQUE, proc_name TEXT UNIQUE, time_defined INT);
	}
}

## Creates the call point table if it does not already exist
#
# \param[in] stage persistence stage DB
proc ::turtles::persistence::init_call_pt_table {stage} {
	$stage eval {
		CREATE TABLE IF NOT EXISTS call_pts
		(caller_id INT, callee_id INT, trace_id INT, time_enter INT, time_leave INT);
		CREATE INDEX IF NOT EXISTS call_pt_edge_idx ON call_pts(caller_id, callee_id);
	}
}

## Creates a number of useful views for aggregate statistics about calls.
#
# \param[in] stage persistence stage DB
proc ::turtles::persistence::init_views {stage} {
	$stage eval {
		CREATE VIEW IF NOT EXISTS calls_by_caller_callee AS
		SELECT caller_name, callee_name, COUNT(*) AS calls, SUM(time_leave - time_enter) AS total_exec_micros, SUM(time_leave - time_enter)/COUNT(*) AS avg_exec_micros
		FROM (SELECT COALESCE(callers.proc_name, "") AS caller_name, callees.proc_name AS callee_name, time_enter, time_leave
			  FROM call_pts
			  LEFT JOIN proc_ids AS callers ON callers.proc_id = caller_id
			  INNER JOIN proc_ids AS callees ON callees.proc_id = callee_id)
		GROUP BY caller_name, callee_name
		ORDER BY total_exec_micros DESC;
	}
	$stage eval {
		CREATE VIEW IF NOT EXISTS calls_by_callee AS
		SELECT callee_name, SUM(calls) AS calls, SUM(total_exec_micros) AS total_exec_micros, SUM(total_exec_micros)/SUM(calls) AS avg_exec_micros
		FROM calls_by_caller_callee
		GROUP BY callee_name
		ORDER BY total_exec_micros DESC;
	}
	$stage eval {
		CREATE VIEW IF NOT EXISTS unused_procs AS
		SELECT callee_name
		FROM (SELECT proc_name AS callee_name
			  FROM proc_ids
			  LEFT JOIN call_pts ON proc_ids.proc_id = call_pts.callee_id
			  WHERE callee_id IS NULL)
		ORDER BY callee_name;
	}
}

## Adds a proc id to the proc id table in the stage 0 persistence DB.
#
# NB: If there is a conflict, i.e., if the given procId and/or procName
# already exist in the stage 0 persistence DB proc_ids table, the existing
# record will NOT be overwritten, and the proc will swallow the conflict.
#
# \param[in] procId proc name hash
# \param[in] procName proc name
# \param[in] timeDefined the epoch time in microseconds at which the proc definition was invoked
proc ::turtles::persistence::add_proc_id {procId procName timeDefined {awaiter {}}} {
	set lambda [::turtles::persistence::lambda::add_proc_id $procId $procName $timeDefined]
	#puts "add_proc_id: $lambda"
	thread::send -async $::turtles::persistence::recorder $lambda $awaiter
}

## Adds a call point to the call point table in the stage 0 persistence DB to record proc entry.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeEnter the epoch time in microseconds at which the proc entry handler was triggered
proc ::turtles::persistence::add_call {callerId calleeId traceId timeEnter {awaiter {}}} {
	set lambda [::turtles::persistence::lambda::add_call $callerId $calleeId $traceId $timeEnter]
	#puts "add_call: $lambda"
	thread::send -async $::turtles::persistence::recorder $lambda $awaiter
}

## Updates a previously added call point in the call point table in the stage 0 persistence DB to record proc exit.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeLeave the epoch time in microseconds at which the proc exit handler was triggered
proc ::turtles::persistence::update_call {callerId calleeId traceId timeLeave {awaiter {}}} {
	set lambda [::turtles::persistence::lambda::update_call $callerId $calleeId $traceId $timeLeave]
	#puts "update_call: $lambda"
	thread::send -async $::turtles::persistence::recorder $lambda $awaiter
}

## The self-perpetuating worker that continually transfers ephemeral trace information to the finalized DB.
#
# This function is only invoked if the persistence model is invoked in \c staged mode.
#
# NB: This function should only be executed directly in the scheduler thread.
#
# \param[in] intervalMillis the number of milliseconds between operations
proc ::turtles::persistence::schedule_finalize {recorderThread stage0 stage1 intervalMillis} {
	if { [thread::exists $recorderThread] } {
		#Finalize the next batch of uncommitted records.
		thread::send $recorderThread [subst { ::turtles::persistence::finalize $stage0 $stage1 }]
		#Set an alarm to wake up and do it again.
		set ::turtles::persistence::nextFinalize [after $intervalMillis ::turtles::persistence::schedule_finalize $recorderThread $stage0 $stage1 $intervalMillis]
	} else {
		error "No active recorder thread!"
	}
}

## Transfers trace information from the ephemeral to the finalized DB.
#
# NB: This function should only be executed directly in the recorder thread.
proc ::turtles::persistence::finalize {stage0 stage1} {
	# Only proceed if the databases exist.
	if { [info comm $stage0 ] ne {} && [info comm $stage1 ] ne {} } {

		# Retrieve last finalize time recorded to stage 1.
		$stage1 eval {
			SELECT COALESCE(MAX(t), 0) AS tmax FROM (SELECT time_defined AS t FROM proc_ids UNION SELECT time_leave AS t FROM call_pts);
		} values {
			set lastFinalizeTime $values(tmax)
		}

		# Copy proc ids from the last finalized to the present into the final DB.
		$stage0 eval {
			SELECT proc_id, proc_name, time_defined FROM proc_ids
			WHERE time_defined > $lastFinalizeTime
		} values {
			$stage1 eval {
				INSERT INTO proc_ids (proc_id, proc_name, time_defined)
				VALUES ($values(proc_id), $values(proc_name), $values(time_defined));
			}
		}
		# Copy _finalized_ call points from the last finalized to the present into the final DB.
		$stage0 eval {
			SELECT caller_id, callee_id, trace_id, time_enter, time_leave FROM call_pts
			WHERE time_leave IS NOT NULL
			  AND time_leave > $lastFinalizeTime
		} values {
			$stage1 eval {
				INSERT INTO call_pts (caller_id, callee_id, trace_id, time_enter, time_leave)
				VALUES ($values(caller_id), $values(callee_id), $values(trace_id), $values(time_enter), $values(time_leave));
			}
		}
	}
}

## Initializes the turtles persistence model.
#
# Note that in \c direct mode the persistence model writes directly to the final DB.
#
# \param[in] finalDB the file for finalized persistence as a sqlite DB
# \param[in] commitMode the mode for persistence (\c staged | \c direct) [default: \c staged]
# \param[in] intervalMillis the number of milliseconds between stage transfers [default: 30000]
proc ::turtles::persistence::start {finalDB {commitMode staged} {intervalMillis 30000}} {
	switch $commitMode {
		staged {
			set ::turtles::persistence::recorder [thread::create -joinable [subst {
				package require Tcl 8.5 8.6
				package require Thread
				package require sqlite3
				package require turtles::persistence
				::turtles::persistence::init_stage ::turtles::persistence::stage0
				::turtles::persistence::init_stage ::turtles::persistence::stage1 $finalDB
				thread::wait
			}]]
			set ::turtles::persistence::scheduler [thread::create [subst {
				package require Tcl 8.5 8.6
				package require Thread
				package require turtles::persistence
				# Pass recorder thread ID to scheduler.
				::turtles::persistence::start_finalizer $::turtles::persistence::recorder ::turtles::persistence::stage0 ::turtles::persistence::stage1 $intervalMillis
				vwait ::turtles::persistence::scheduler_off
			}]]
		}
		direct {
			set ::turtles::persistence::recorder [thread::create -joinable [subst {
				package require Tcl 8.5 8.6
				package require Thread
				package require sqlite3
				package require turtles::persistence
				::turtles::persistence::init_stage ::turtles::persistence::stage0 $finalDB
				thread::wait
			}]]
		}
		default {
			error "::turtles::persistence::start: invalid commit mode '$commitMode'. Valid options are 'staged' or 'direct'."
		}
	}
}

## Initializes a given stage in the persistence model.
#
# Under the hood, this creates the sqlite database and the requisite tables
# for storing trace information.
#
# Without a \c stageName argument, it defaults to an in-memory database.
# It is recommended to invoke this variant only once during execution.
#
# \param[in] stage the stage command (i.e., sqlite DB) to be used for this stage
# \param[in] stageName the filename of the sqlite DB (default = \c :memory:)
proc ::turtles::persistence::init_stage {stage {stageName :memory:}} {
	sqlite3 $stage $stageName
	::turtles::persistence::init_proc_id_table $stage
	::turtles::persistence::init_call_pt_table $stage
	::turtles::persistence::init_views $stage
}

## Tears down a given stage in the persistence model.
#
# Under the hood, this closes the associated sqlite DB.
# The associated command will no longer be available after this completes.
#
# \param[in] stage the stage command (i.e., sqlite DB)
proc ::turtles::persistence::close_stage {stage} {
	if { [info comm $stage] ne {} } {
		$stage close
	}
}

## Kicks off the periodic prompt in the scheduler to notify the recorder to
# transfer new trace information from stage 0 to stage 1.
#
# \param recorderThread the thread ID of the recorder thread
# \param stage0 the stage 0 command (i.e., sqlite DB) for ephemeral storage
# \param stage1 the stage 1 command (i.e., sqlite DB) for finalized storage
# \param intervalMillis the interval in ms between finalize notifications
proc ::turtles::persistence::start_finalizer {recorderThread stage0 stage1 intervalMillis} {
	set ::turtles::persistence::nextFinalize [after $intervalMillis ::turtles::persistence::schedule_finalize $recorderThread $stage0 $stage1 $intervalMillis ]
}

## Terminates the periodic prompt in the scheduler to notify the recorder
# to transfer new trace information from stage 0 to stage 1.
#
# Invocation of this proc forces an \c update in the scheduler thread
# to execute any pending tasks in the Tcl event loop for the thread.
# Any new finalize prompt scheduled after this update is cancelled.
# In lieu of a scheduled prompt, an explicit finalize notification is
# made to the recorder thread to catch the last trace information
# that has not been transferred from stage 0 to stage 1.
#
# The variable holding the pointer to the next finalize prompt is unset.
#
# NB: This should not be invoked while trace handlers which could modify
# the stage databases are active.
proc ::turtles::persistence::stop_finalizer {recorderThread stage0 stage1} {
	# Force any pending finalize call to execute.
	update
	# Cancel the newly pending finalize call.
	after cancel $::turtles::persistence::nextFinalize
	# Do a last finalize to pick up any missing trace information.
	if { [thread::exists $recorderThread] } {
		thread::send $recorderThread [subst {
			::turtles::persistence::finalize $stage0 $stage1
		}]
	}
	# Remove the pending finalize call handle.
	unset ::turtles::persistence::nextFinalize
}

## Halts and tears down the turtles persistence model.
#
# If the model is operating in \c staged mode, any pending
# ::turtles::persistence::finalize call is cancelled, and an
# explicit call is made immediately to transfer the remaining
# unfinalized information from the ephemeral to the finalized DB.
#
# The underlying sqlite DB(s) introduced via \c ::turtles::persistence::start
# are closed and any pertinent namespace variables are unset.
#
# NB: This proc should not be called until all the relevant trace hooks are eliminated.
proc ::turtles::persistence::stop {} {
	# Stop scheduler worker thread.
	if { [info exists ::turtles::persistence::scheduler] && [thread::exists $::turtles::persistence::scheduler] } {
		set lambda [::turtles::persistence::lambda::stop_scheduler $::turtles::persistence::recorder]
		thread::send $turtles::persistence::scheduler $lambda
	}

	# Stop recorder worker thread.
	if { [info exists ::turtles::persistence::recorder] && [thread::exists $::turtles::persistence::recorder] } {
		set lambda [::turtles::persistence::lambda::stop_recorder]
		thread::send $turtles::persistence::recorder $lambda
		thread::release $::turtles::persistence::recorder
		thread::join $::turtles::persistence::recorder
	}
}

package provide turtles::persistence 0.1
