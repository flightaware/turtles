#!/usr/bin/env tclsh
package require Tcl     8.5 8.6
package require Thread
package require sqlite3

package require turtles::persistence::base 0.1

## \file persistence_ev.tcl
#
# Persistence requests are executed immediately. A self-recurring \c after
# job runs in the Tcl event loop to ensure that ephemeral data
# is finalized.
#
# To persist trace information, it is recommended to invoke
# \c ::turtles::persistence::ev::start with the appropriate parameters
# and _then_ add trace hooks.
# To stop persistence, it is recommended to remove the relevant
# trace hooks and _then_ invoke \c ::turtles::persistence::ev::stop.

## Namespace for handling persistence of trace information generated by the turtles package.
#
# The scheduling of staged persistence is accomplished solely through the Tcl event loop.
namespace eval ::turtles::persistence::ev {
	variable stages
	namespace export start stop add_proc_id add_call update_call stages
}

## Adds a proc id to the proc id table in the stage 0 persistence DB.
#
# NB: If there is a conflict, i.e., if the given procId and/or procName
# already exist in the stage 0 persistence DB proc_ids table, the existing
# record will NOT be overwritten, and the proc will swallow the conflict.
#
# \param[in] procId proc name hash
# \param[in] procName proc name
# \param[in] timeDefined the epoch time in microseconds at which the proc definition was invoked
# \param[in] awaiter an optional variable name reference that the caller can await on
proc ::turtles::persistence::ev::add_proc_id {procId procName timeDefined {awaiter {}}} {
	eval [::turtles::persistence::base::add_proc_id [namespace current]::stages $procId $procName $timeDefined]
}

## Adds a call point to the call point table in the stage 0 persistence DB to record proc entry.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeEnter the epoch time in microseconds at which the proc began
# \param[in] timeLeave the epoch time in microseconds at which the proc finished (optional)
# \param[in] awaiter an optional variable name reference that the caller can await on
proc ::turtles::persistence::ev::add_call {callerId calleeId traceId timeEnter {timeLeave {NULL}} {awaiter {}}} {
	eval [::turtles::persistence::base::add_call [namespace current]::stages $callerId $calleeId $traceId $timeEnter $timeLeave]
}

## Updates a previously added call point in the call point table in the stage 0 persistence DB to record proc exit.
#
# \param[in] callerId proc name hash of the caller
# \param[in] calleeId proc name hash of the callee, i.e., the function of interest
# \param[in] traceId identifier disambiguating calls on the same caller-callee edge in the call graph
# \param[in] timeLeave the epoch time in microseconds at which the proc exit handler was triggered
# \param[in] awaiter an optional variable name reference that the caller can await on
proc ::turtles::persistence::ev::update_call {callerId calleeId traceId timeLeave {awaiter {}}} {
	eval [::turtles::persistence::base::update_call [namespace current]::stages $callerId $calleeId $traceId $timeLeave]
}

## Initializes the turtles persistence model.
#
# Note that in \c direct mode the persistence model writes directly to the final DB.
#
# \param[in] commitMode the mode for persistence (\c staged | \c direct) [default: \c staged]
# \param[in] intervalMillis the number of milliseconds between stage transfers [default: 30000]
# \param[in] dbPath the path where the finalized persistence is stored as a sqlite DB [default: ./]
# \param[in] dbPrefix the filename prefix of the finalized persistence is stored as a sqlite DB. The PID and .db extension are appended [default: turtles]
proc ::turtles::persistence::ev::start {{commitMode staged} {intervalMillis 30000} {dbPath ./} {dbPrefix {turtles}}} {
	set fqdb [turtles::persistence::base::get_db_filename $dbPath $dbPrefix]
	switch $commitMode {
		staged {
			::turtles::persistence::base::init_stages [namespace current]::stages $commitMode $fqdb
			::turtles::persistence::ev::start_finalizer [namespace current]::nextFinalizeCall [namespace current]::stages $intervalMillis
		}
		direct {
			::turtles::persistence::base::init_stages [namespace current]::stages $commitMode $fqdb
		}
		default {
			error "::turtles::persistence::start: invalid commit mode '$commitMode'. Valid options are 'staged' or 'direct'."
		}
	}
}


## Halts and tears down the turtles persistence model.
#
# If the model is operating in \c staged mode, any pending
# \c ::turtles::persistence::base::finalize call is cancelled, and an
# explicit call is made immediately to transfer the remaining
# unfinalized information from the ephemeral to the finalized DB.
#
# The underlying sqlite DB(s) introduced via \c ::turtles::persistence::ev::start
# are closed and any pertinent namespace variables are unset.
#
# NB: This proc should not be called until all the relevant trace hooks are eliminated.
proc ::turtles::persistence::ev::stop {} {
	::turtles::persistence::base::stop_finalizer [namespace current]::nextFinalizeCall
	::turtles::persistence::base::stop_recorder [namespace current]::stages
}

## Kicks off the periodic prompt in the scheduler to notify the recorder to
# transfer new trace information from stage 0 to stage 1.
#
# \param nextRef the variable name reference pointing to the next pending finalize trigger
# \param stages the command (i.e., sqlite DB) for ephemeral storage and attached finalized storage
# \param intervalMillis the interval in ms between finalize notifications
proc ::turtles::persistence::ev::start_finalizer {nextRef stages intervalMillis} {
	upvar $nextRef next
	set next [after $intervalMillis ::turtles::persistence::ev::schedule_finalize next $stages $intervalMillis ]
}

## The self-perpetuating worker that continually transfers ephemeral trace information to the finalized DB.
#
# This function is only invoked if the persistence model is invoked in \c staged mode.
#
# NB: This function should only be executed directly in the scheduler thread.
#
# \param nextRef the variable name reference pointing to the next pending finalize trigger
# \param stages the command (i.e., sqlite DB) for ephemeral storage and attached finalized storage
# \param intervalMillis the interval in ms between finalize notifications
proc ::turtles::persistence::ev::schedule_finalize {nextRef stages intervalMillis} {
	upvar $nextRef next
	::turtles::persistence::base::finalize $stages
	set ::turtles::persistence::base::nextFinalizeCall [after $intervalMillis ::turtles::persistence::ev::schedule_finalize next $stages $intervalMillis]
}

package provide turtles::persistence::ev 0.1
